import { expect } from 'chai';
import { BigNumber } from 'ethers';
import { MAX_UINT_AMOUNT } from '../helpers/constants';
import { convertToCurrencyDecimals } from '../helpers/contracts-helpers';
import { makeSuite, TestEnv } from './helpers/make-suite';
import { waitForTx, evmSnapshot, evmRevert } from '@aave/deploy-v3';
import { HardhatRuntimeEnvironment } from 'hardhat/types';

declare var hre: HardhatRuntimeEnvironment;

makeSuite('Rounding exploit prevention', (testEnv: TestEnv) => {
  let snap: string;

  before(async () => {
    snap = await evmSnapshot();
  });

  after(async () => {
    await evmRevert(snap);
  });

  it('Supply/withdraw cycle should never return more than deposited (low-decimal token)', async () => {
    const { pool, usdc, users, dai } = testEnv;
    const attacker = users[0];
    const whale = users[1];
    const borrower = users[2];

    // --- Setup: create a non-trivial liquidityIndex by having active borrows ---

    // Whale supplies USDC (6 decimals, similar to WBTC's 8)
    const whaleAmount = await convertToCurrencyDecimals(usdc.address, '100000');
    await waitForTx(
      await usdc.connect(whale.signer)['mint(address,uint256)'](whale.address, whaleAmount)
    );
    await waitForTx(
      await usdc.connect(whale.signer).approve(pool.address, MAX_UINT_AMOUNT)
    );
    await waitForTx(
      await pool.connect(whale.signer).supply(usdc.address, whaleAmount, whale.address, 0)
    );

    // Borrower supplies DAI as collateral then borrows USDC
    const daiCollateral = await convertToCurrencyDecimals(dai.address, '1000000');
    await waitForTx(
      await dai.connect(borrower.signer)['mint(address,uint256)'](borrower.address, daiCollateral)
    );
    await waitForTx(
      await dai.connect(borrower.signer).approve(pool.address, MAX_UINT_AMOUNT)
    );
    await waitForTx(
      await pool.connect(borrower.signer).supply(dai.address, daiCollateral, borrower.address, 0)
    );
    const borrowAmount = await convertToCurrencyDecimals(usdc.address, '50000');
    await waitForTx(
      await pool.connect(borrower.signer).borrow(usdc.address, borrowAmount, 2, 0, borrower.address)
    );

    // Advance time to accrue interest and push liquidityIndex above 1.0
    await hre.network.provider.send('evm_increaseTime', [365 * 24 * 3600]); // 1 year
    await hre.network.provider.send('evm_mine');

    // --- Exploit attempt ---

    // Mint seed USDC to attacker
    const seedAmount = await convertToCurrencyDecimals(usdc.address, '1000');
    await waitForTx(
      await usdc.connect(attacker.signer)['mint(address,uint256)'](attacker.address, seedAmount)
    );
    await waitForTx(
      await usdc.connect(attacker.signer).approve(pool.address, MAX_UINT_AMOUNT)
    );

    // The magic number: 417 units is the amount the real attacker used
    const attackAmount = BigNumber.from(417);
    const balanceBefore = await usdc.balanceOf(attacker.address);

    // Run 50 supply/withdraw cycles (same as the real attacker)
    for (let i = 0; i < 50; i++) {
      await waitForTx(
        await pool.connect(attacker.signer).supply(usdc.address, attackAmount, attacker.address, 0)
      );
      await waitForTx(
        await pool
          .connect(attacker.signer)
          .withdraw(usdc.address, MAX_UINT_AMOUNT, attacker.address)
      );
    }

    const balanceAfter = await usdc.balanceOf(attacker.address);

    // CRITICAL ASSERTION: attacker must NOT profit from rounding
    // With the fix: balanceAfter <= balanceBefore (rounding favors the protocol)
    // Without the fix: balanceAfter > balanceBefore (attacker profits 1 unit per cycle)
    expect(balanceAfter).to.be.lte(
      balanceBefore,
      `Rounding exploit: attacker gained ${balanceAfter.sub(balanceBefore).toString()} units`
    );

    const loss = balanceBefore.sub(balanceAfter);
    console.log(
      `    Attacker loss over 50 cycles: ${loss.toString()} units (rounding in protocol favor)`
    );
  });

  it('withdraw(MAX_UINT) should not revert due to overstated balanceOf', async () => {
    const { pool, usdc, aUsdc, users } = testEnv;
    const user = users[3];

    // Supply a small amount
    const supplyAmount = BigNumber.from(417);
    await waitForTx(
      await usdc.connect(user.signer)['mint(address,uint256)'](user.address, supplyAmount)
    );
    await waitForTx(
      await usdc.connect(user.signer).approve(pool.address, MAX_UINT_AMOUNT)
    );
    await waitForTx(
      await pool.connect(user.signer).supply(usdc.address, supplyAmount, user.address, 0)
    );

    // Advance time to accrue interest
    await hre.network.provider.send('evm_increaseTime', [30 * 24 * 3600]); // 30 days
    await hre.network.provider.send('evm_mine');

    const reportedBalance = await aUsdc.balanceOf(user.address);

    // This must not revert — balanceOf (floor-rounded) should never exceed
    // what the burn path actually processes
    await waitForTx(
      await pool.connect(user.signer).withdraw(usdc.address, MAX_UINT_AMOUNT, user.address)
    );

    const received = await usdc.balanceOf(user.address);
    console.log(
      `    Reported balance: ${reportedBalance.toString()}, Received: ${received.toString()}`
    );

    // User should have received at least the reported balance
    // (the pool sends `amountToWithdraw` which is derived from the floor-rounded balance)
    expect(received).to.be.gte(reportedBalance);
  });

  it('Large deposit/withdraw should work correctly and earn interest', async () => {
    const { pool, usdc, users } = testEnv;
    const user = users[4];

    const amount = await convertToCurrencyDecimals(usdc.address, '10000');
    await waitForTx(
      await usdc.connect(user.signer)['mint(address,uint256)'](user.address, amount)
    );
    await waitForTx(
      await usdc.connect(user.signer).approve(pool.address, MAX_UINT_AMOUNT)
    );
    await waitForTx(
      await pool.connect(user.signer).supply(usdc.address, amount, user.address, 0)
    );

    // Advance time to accrue interest
    await hre.network.provider.send('evm_increaseTime', [30 * 24 * 3600]); // 30 days
    await hre.network.provider.send('evm_mine');

    await waitForTx(
      await pool.connect(user.signer).withdraw(usdc.address, MAX_UINT_AMOUNT, user.address)
    );

    const finalBalance = await usdc.balanceOf(user.address);

    // With interest accrued, user should get back at least their deposit
    // Floor rounding may cost a fraction of a unit, but interest more than covers it
    expect(finalBalance).to.be.gte(amount);
    console.log(`    Deposited: ${amount.toString()}, Withdrew: ${finalBalance.toString()}`);
  });

  it('18-decimal token should be unaffected by rounding changes', async () => {
    const { pool, dai, users } = testEnv;
    const user = users[0];

    const amount = await convertToCurrencyDecimals(dai.address, '1000');
    await waitForTx(
      await dai.connect(user.signer)['mint(address,uint256)'](user.address, amount)
    );
    await waitForTx(
      await dai.connect(user.signer).approve(pool.address, MAX_UINT_AMOUNT)
    );
    await waitForTx(
      await pool.connect(user.signer).supply(dai.address, amount, user.address, 0)
    );

    // Immediate withdraw — 18-decimal tokens should barely be affected
    await waitForTx(
      await pool.connect(user.signer).withdraw(dai.address, MAX_UINT_AMOUNT, user.address)
    );

    const finalBalance = await dai.balanceOf(user.address);
    const diff = finalBalance.sub(amount).abs();

    // For 18-decimal tokens, the difference should be at most 1 wei
    expect(diff).to.be.lte(1);
    console.log(
      `    DAI deposited: ${amount.toString()}, final: ${finalBalance.toString()}, diff: ${diff.toString()} wei`
    );
  });
});
